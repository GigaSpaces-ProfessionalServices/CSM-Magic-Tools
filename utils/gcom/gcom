#!/bin/bash

# GENERAL:
#   gcom - Gigaspaces Components Orchestration Manager
# 
# DESCRIPTION:
#   supports unattended or interactive gs component deployment


VERSION=0.2.3


function usage() {
cat << EOF

$(basename $0) version $VERSION
Copyright (C) 2023 Gigaspace Inc. by Alon Segal.

USAGE:
    interactive: $(basename $0)
    or
    unattended:  $(basename $0) [Commands] [Options]

DESCRIPTION:
    * microservices deployment operations (multiple selection supported)
    * interactive 'wizard-like' mode using presets to streamline executions
    * unattended mode for full automation
    * choose between complete deployment or selected operations for a more granular control of execution
    * supports multi-instance deployments with smart container distribution across grid space nodes

COMMANDS:
    full        Complete service deployment - execute all commands.
    create      Create containers for a service
    deploy      Deploy a processing unit
    kill        Delete containers
    undeploy    Undeploy a processing unit
    list        List space resources accross hosts
    version     Show version

OPTIONS:
    -s          Path to the service
    -j          Jar file to deploy
    -c          Total number of containers to create
    -m          Memory allocation size (human readable e.g. 512m, 2g)
    -i          Number of instances
    -v          Increase verbosity
    -x          Enter additional pu deployment parameters
    -p          Specify port range (format: 1000-1200)
    -o          Supply additional JVM options for deploy stage
                Supported placeholders:
                    * [ZONE] - the zone name
                    * [SERVICE] - same as zone name
                    * [SERVICE_NAME] - the value of [SERVICE] with the '_service' suffix
                    * [JAR] - the full path to the jar file
                    * [JVM_RAM] - the allocated memory size in human readable format (e.g. 512m, 2g)
    -h,--help   Show usage

EXAMPLES:
    unattended full deployment
        $(basename $0) full -s <SERVICE_PATH> -c <NUM_OF_CONTAINERS> -m <JVM_RAM> -i <NUM_OF_INSTANCES> -j <JAR_PATH> -p <PORT-RANGE>
    
    unattended undeploy pu only
        $(basename $0) undeploy -s <SERVICE_PATH>
    
    unattended kill containers only
        $(basename $0) kill -s <SERVICE_PATH>
    
    unattended create containers only
        $(basename $0) create -s <SERVICE_PATH> -c <NUM_OF_CONTAINERS> -m <JVM_RAM>
    
    unattended deploy pu only
        $(basename $0) deploy -s <SERVICE_PATH> -i <NUM_OF_INSTANCES> -j <JAR_PATH> -p <PORT-RANGE>
    
    unattended deploy pu only with additional options GS_OPTIONS_EXT using placeholder [ZONE]
        $(basename $0) deploy -s <SERVICE_PATH> -i <NUM_OF_INSTANCES> -j <JAR_PATH> -o "-Xlog:gc*:file=/tmp/[ZONE]_gc_%p.log:time,level"
    * [ZONE] placeholder for -Xlog:gc*:file will be replaced with the appropriate value during runtime

EOF
}


function bash_version_ok() {
    local this_version=$(echo $BASH_VERSION | cut -d. -f1-2)
    [[ $(echo "$this_version >= $BASH_REQUIRED" | bc -l) == 1 ]] && return 0 || return 1
}


function print_gs_logo() {
    clear ; clear
    printf '#%.0s' {1..80} ; echo                       # line 1
    echo -n "#" ; printf ' %.0s' {1..78} ; echo "#"     # line 2
    echo -n "#" ; printf ' %.0s' {1..8}                 # line 3
    echo -n -e "${_lr}*${_res} ${_lg}/${_res} * "       # line 3
    printf ' %.0s' {1..64} ; echo "#"                   # line 3
    echo -n "#" ; printf ' %.0s' {1..5}                             # line 4
    echo -n -e "${_lb}/${_res} ${_lr}/${_res} ${_lg}/${_res} / * "  # line 4
    printf ' %.0s' {1..23} ; echo -n "G . C . O . M"                # line 4
    printf ' %.0s' {1..27} ; echo "#"                               # line 4
    echo -n "#" ; printf ' %.0s' {1..4}                                             # line 5
    echo -n -e "/ ${_o}/${_res} ${_lg}/${_res} ${_b}/${_res} ${_b}/${_res}"         # line 5
    printf ' %.0s' {1..10} ; echo -n "Gigaspaces Components Orchestration Manager"  # line 5
    printf ' %.0s' {1..12} ; echo "#"                                               # line 5
    echo -n "#" ; printf ' %.0s' {1..5}                                     # line 6
    echo -n -e "${_o}/${_res} ${_b}/${_res} ${_b}/${_res} ${_b}*${_res}"    # line 6
    printf ' %.0s' {1..66} ; echo "#"                                       # line 6
    echo -n "#" ; printf ' %.0s' {1..78} ; echo "#"     # line 7
    printf '#%.0s' {1..80} ; echo ; echo                       # line 8
}


function print_menu_header() {
    local key="$1"
    local header="$2"
    local line="$key $header"
    local length=$(expr ${#line} + 6)
    printf "\n:: ${key} :: ${header}\n"
    printf '‾%.0s' $(seq "$length")
    printf "\n"
}


function pause() {
    echo ; read -s -p "Press ENTER to continue "
}


function menu_builder(){
    declare -ga current_menu_names=()
    declare -ga current_menu_descriptions=()
    if [[ ${#wizard_selections[@]} -eq 0 ]]; then
        target_branch=0
    else
        target_branch=$(echo "${wizard_selections[@]}" | sed 's/ /\./g')
    fi

    # get this branch's keys
    declare -a leafs=()
    for key in "${!menu_items[@]}"; do
        if [[ $target_branch == 0 ]] && [[ "$key" =~ ^[0-9]+$ ]]; then
            local leaf="${key%.*}"
            local leafs+=($leaf)
        else
            [[ "$key" =~ ^[0-9]+$ ]] && continue
            local this_key_branch="${key%.*}"
            if [[ $this_key_branch == $target_branch ]]; then
                local leaf="${key##*.}"
                local leafs+=($leaf)
            fi
        fi
    done
    # sort the leafs to print the menu
    sorted_leafs=($(for k in "${leafs[@]}"; do echo "$k"; done | sort -n))

    # print selected branch leafs
    for leaf in ${sorted_leafs[@]}; do
        [[ $target_branch == 0 ]] && key=$leaf || key="${target_branch}.${leaf}"
        current_menu_names+=("$(echo ${menu_items["$key"]} | cut -d, -f1 | cut -d= -f2)")
        current_menu_descriptions+=("$(echo ${menu_items["$key"]} | cut -d, -f4 | cut -d= -f2)")
    done
}


function print_menu_items() {
    # Description:
    #       read any input array as menu and write any user selection(s) to output array
    # Parameters:
    # --in 'array_name[@]'      read menu items from this array
    # --out 'array_name'        write selections to this array
    # --desc 'array_name[@]'    read descriptions for menu items
    # -a                        append to wizard array (default: reset output array for regular selection)
    # -m                        multiple selection support (default is single) *** doesn't work with -a ***
    
    local select_mode="single"
    local is_wizard_array=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --in) shift ; local source_array=("${!1}") ;;
            --out) shift ; local this_arr="$1" ; declare -n target_array="$this_arr" ;;
            --desc) shift ; local desc_arr=("${!1}") ;;
            -m) local select_mode="multiple" ;;
            -a) is_wizard_array=true ;;
        esac
        shift
    done

    # check required parameters
    [[ -z $source_array ]] && echo "invalid function call: missing 'source_array'" && exit 1
    [[ -z $this_arr ]] && echo "invalid function call: missing 'target_array'" && exit 1

    # check parameter conflicts
    if [[ $select_mode == "multiple" ]] && $is_wizard_array ; then
        echo "bad function call: '-a' and '-m' are incompatible"
        return
    fi

    # reset output array if append (-a) not set
    $is_wizard_array || target_array=()

    function is_valid_number() {
        local user_input=$1
        local max_items=$2
        if [[ "$user_input" =~ ^[0-9]+$ ]]; then
            if [[ $user_input -lt 0 ]] || [[ $user_input -gt $max_items ]]; then
                echo false
            else
                echo true
            fi
        else
            echo false
        fi
    }

    function is_valid_range() {
        # check if input is a valid range (e.g. 1-4)
        local user_input=$1
        local max_items=$2
        if [[ "$user_input" == *"-"* ]]; then
            min_val=$(echo $user_input | cut -d- -f1)
            max_val=$(echo $user_input | cut -d- -f2)
            $(is_valid_number $min_val $max_items) && \
            $(is_valid_number $max_val $max_items) && \
            echo true || echo false
        else
            echo false
        fi
    }

    # print the menu (with / without descriptions)
    for ((i=0; i<${#source_array[@]}; i++)); do
        if [[ ! -z $desc_arr ]]; then
            printf "\e${_y}%-4s${_res} \e${_w}%-20s${_res} \
            - \e${_w}${desc_arr[$i]}${_res}\n" "[$((i+1))]" "${source_array[$i]}"
        else
            printf "\e${_y}%-4s${_res} \e${_w}%-20s${_res} \n" "[$((i+1))]" "${source_array[$i]}"
        fi
    done

    # add quit option
    echo ; printf '=%.0s' {1..80}
    echo -e "\n${_y}[0]${_res} Quit / Back\n"

    if [[ $select_mode == 'single' ]]; then
        unset num
        while true; do
            read -p "#? " num
            if [[ $num == 0 ]]; then
                if $is_wizard_array ; then
                    [[ ${#target_array[@]} == 0 ]] && exit 0
                    unset target_array[$((${#target_array[@]} - 1))]
                fi
                break
            elif $(is_valid_number $num ${#source_array[@]}); then
                target_array+=($num)
                break
            else
                [[ ${#source_array[@]} -gt 1 ]] && range="1-${#source_array[@]}" || range="1"
                echo "invalid input! select between 0 or $range"
            fi
        done
    elif [[ $select_mode == 'multiple' ]]; then
        input_valid=false
        unset choices
        until $input_valid; do
            read -p "#? " choices
            choices=$(echo $choices | sed 's/ *//g;s/,/ /g')  # convert to list
            
            # if choice is 0 we exit this menu
            $(echo "$choices" | grep -wq 0) && break
            
            for num in $choices; do
                if $(is_valid_range $num ${#source_array[@]}); then
                    local min_val=$(echo $num | cut -d- -f1)
                    local max_val=$(echo $num | cut -d- -f2)
                    # correct inverted range
                    if [[ $min_val -gt $max_val ]]; then
                        local t=$min_val; min_val=$max_val ; max_val=$t
                    fi
                    for n in $(eval echo {$min_val..$max_val}); do
                        target_array+=($n)
                    done
                    input_valid=true
                    continue
                elif $(is_valid_number $num ${#source_array[@]}); then
                    target_array+=($num)
                    input_valid=true
                    continue
                else
                    [[ ${#source_array[@]} -gt 1 ]] && range="1-${#source_array[@]}" || range="1"
                    echo "invalid input! select between 0 or $range"
                    input_valid=false
                    break
                fi
            done
        done
    fi
}


function print_vars() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] MANAGER set to: $MANAGER" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] NUM OF SPACES set to: $NUM_OF_SPACES" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] SERVICE_PATH set to: $SERVICE_PATH" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] SERVICE | ZONE set to: $SERVICE" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] SERVICE_NAME set to: $SERVICE_NAME" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] NUM_OF_CONTAINERS set to: $NUM_OF_CONTAINERS" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] JVM_RAM set to: $JVM_RAM" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] PORT_RANGE set to: $PORT_RANGE" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] NUM_OF_INSTANCES set to: $NUM_OF_INSTANCES" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] JAR set to: $JAR" >> $LOG
    if [[ ! -z $DEPLOY_PARAMS ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] DEPLOY_PARAMS set to: $DEPLOY_PARAMS" >> $LOG
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] DEPLOY_PARAMS not set" >> $LOG
    fi
    if [[ ! -z $GS_EXT ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] GS_EXT set to: $GS_EXT" >> $LOG
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] GS_EXT not set" >> $LOG
    fi
}


function logger() {
    local log_file="$1"
    local cmd="${@:2}"

    { $cmd 2>&1 | \
    tee >(while read -r line; do 
            echo "$(date '+%Y-%m-%d %H:%M:%S') $line";
        done >> "$log_file"); } 2>&1
}


function print_mem_size_human() {
    local num=$1
    local d=1000    # common devider
    local deviders=( $d $(($d**2)) $(($d**3)) )
    local units=( "KB" "MB" "GB" )

    for ((i=0; i<${#deviders[*]}; i++)); do
        if [[ $(expr $num / ${deviders[$i]}) -lt 1000 ]]; then
            echo "$(echo "scale=2 ; $num / ${deviders[$i]}" | bc) ${units[$i]}"
            break
        fi
    done
}


function is_number() {
    local input="$1"
    [[ "$input" =~ ^[0-9]+$ ]] && echo true || echo false
}


function get_cluster_hosts {
    local cluster_name=$1
    local prefix=$2
    local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
    sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" \
        ${ENV_CONFIG}/host.yaml |
    awk -F$fs '{
        indent = length($1)/2;
        vname[indent] = $2;
        for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
        }
    }' | while read line; do
        [[ "$line" =~ .*"${cluster_name}_host".* ]] && \
        echo $line | sed 's/ *//g' | sed 's/"//g' | cut -d= -f2
    done
}


function get_auth() {
    sec_flag=$(cat ${ENV_CONFIG}/app.config | grep "app.setup.profile" | cut -d= -f2)
    if [[ $sec_flag != "" ]]; then
        declare -g AUTH_USER=$(cat ${ENV_CONFIG}/app.config | grep "app.manager.security.username" | cut -d= -f2)
        declare -g AUTH_PASS=$(cat ${ENV_CONFIG}/app.config | grep "app.manager.security.password" | cut -d= -f2)
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] environment secured. extracted username/password from app.config" >> $LOG
    else
        declare -g AUTH_USER=""
        declare -g AUTH_PASS=""
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] environment not secured. username/password not set" >> $LOG
    fi
}
    

function is_manager_rest_ok() {
    local the_manager=$1
    local port_ok=false
    local rest_ok=false

    # check port
    nc -z $m 8090 && port_ok=true
    
    # check rest
    local rest="http://${the_manager}:8090/v2/index.html"
    local status_code=$(curl -u "$AUTH_USER:$AUTH_PASS" \
    --write-out '%{http_code}' --silent --output /dev/null "$rest")
    [[ $status_code -eq 200 ]] && rest_ok=true
    
    ($port_ok && $rest_ok) && return 0 || return 1
}


function list_resources() {
    local uri="http://${MANAGER}:8090/v2/containers"
    echo
    printf "%-20s | %-12s | %-10s | %-10s | %-12s\n" "Hostname" "IP" "Containers" "Total RAM" "Available RAM"
    printf '‾%.0s' {1..77} ; echo
    while read -r line; do
        h_name=$(echo $line | awk '{print $2}' | sed 's/ //g')
        h_ip=$(nslookup $h_name | grep 'Address' | awk 'NR==2 {print $2}' | sed 's/ //g')
        cont=$(echo $line | awk '{print $1}' | sed 's/ //g')
        tmem=$(print_mem_size_human $(echo ${SPACE_MEM_INFO["$h_ip"]} | sed -n 's/.*MemTotal=\([^,]*\).*/\1/p'))
        amem=$(print_mem_size_human $(echo ${SPACE_MEM_INFO["$h_ip"]} | sed -n 's/.*MemAvailable=\([^,]*\).*/\1/p'))
        printf "%-20s   %-12s   %-10s   %-10s   %-12s\n" "$h_name" "$h_ip" "$cont" "$tmem" "$amem"
    done < <(curl -sk -u "$AUTH_USER:$AUTH_PASS" $uri | jq -r '.[].id' | sed 's/~.*//g' | sort | uniq -c | sed 's/^ *//')
    printf '_%.0s' {1..77} ; echo
    echo
}


function mem_used_per_space_host() {
    # build a global meminfo dictionary for each space host
    # format: [host]:['MemTotal=KB_VAL,MemAvailable=KB_VAL']
    space_hosts=$(get_cluster_hosts space)
    
    # loop using free instead of /proc/meminfo
    for h in $space_hosts; do
        info=$(ssh "$h" 'free -b' | awk 'NR==2 {printf "MemTotal=%s,MemAvailable=%s", $2, $7}')
        SPACE_MEM_INFO["$h"]="$info"
    done
}


function get_max_free_mem_host() {
    declare -n free_mem_array="$1"
    local optimal_host=""
    local max_free=""

    for h in ${!free_mem_array[*]}; do
        current=$(echo ${free_mem_array[$h]} | sed -n 's/.*MemAvailable=\([^,]*\).*/\1/p')
        if [[ $current -gt $max_free ]]; then
            max_free=$current
            optimal_host=$h
        fi
    done
    echo $optimal_host
}


function warn_incompatible_ram_allocation() {
    # calculate the amount of total requested RAM per host against 
    # the available RAM per host to see if RAM is available
    echo "calculating ..."
}


function get_services() {
    local mode=$1   # interactive | unattended
    local section_name=$2
    if [[ $mode == "interactive" ]]; then
        print_menu_header "$section_name" "Choose service(s) from the list:"
        print_menu_items --in AVAILABLE_SERVICES[@] --out user_selections -m
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $SERVICE_PATH ]]; then
            echo -e "\n[ERROR] missing path to service. use -h for help."
            exit 1
        elif [[ ! -d $SERVICE_PATH ]]; then
            echo -e "\n[ERROR] service not found or invalid path."
            exit 1
        fi
        declare -g SERVICE=$(echo $(basename "$SERVICE_PATH") | tr '[:upper:]' '[:lower:]')
        declare -g ZONE=$SERVICE
        declare -g SERVICE_NAME="${SERVICE}_service"
    fi
}


function get_num_of_instances() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "INSTANCES" "How many instances of the service to deploy?"
        while true; do
            read -p "#? " res
            [[ "$res" =~ ^[0-9]+$ ]] && [[ "$res" -gt 0 ]] && break
            echo "Invalid input!"
        done
        declare -g NUM_OF_INSTANCES=$res
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $NUM_OF_INSTANCES ]]; then
            echo -e "\n[ERROR] number of instances not set. use -h for help."
            exit 1
        fi
    fi
}


function get_num_of_containers() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "CONTAINERS" "Enter how many containers to create for this service:"
        while true; do
            read -p "#? " res
            [[ "$res" =~ ^[0-9]+$ ]] && [[ "$res" -gt 0 ]] && break
            echo "Invalid input!"
        done
        declare -g NUM_OF_CONTAINERS=$res
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $NUM_OF_CONTAINERS ]]; then
            echo -e "\n[ERROR] number of containers not set. use -h for help."
            exit 1
        fi
    fi
    declare -g TOTAL_NUM_OF_CONTAINERS=$(expr $NUM_OF_CONTAINERS \* $NUM_OF_SPACES)
}


function get_memory_allocation() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "MEMORY" "How much RAM to allocate for each container [e.g. 512m or 1g]:"
        while true; do
            read -p "#? " res
            [[ "$res" =~ [mg] ]] && [[ "$( echo $res | sed 's/[mg]//')" =~ ^[0-9]+$ ]] && break
            echo "Invalid input!"
        done
        declare -g JVM_RAM=$res
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $JVM_RAM ]]; then
            echo -e "\n[ERROR] memory allocation size not set. use -h for help."
            exit 1
        fi
    fi
}


function get_jar_file() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "RESOURCE" "Select a jar file for deployment(s):"
        print_menu_items --in AVAILABLE_JARS[@] --out user_selections
    elif [[ $mode == "unattended" ]]; then
        if [[ -z $JAR ]]; then
            echo -e "\n[ERROR] missing path to jar file. use -h for help."
            exit 1
        elif [[ ! -e $JAR ]]; then
            echo -e "\n[ERROR] jar file not found or invalid path."
            exit 1
        fi
    fi
}


function set_port_range() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "PORTS" "Specify a port range (default: 8113-8311):"
        while true; do
            read -p "#? " range
            # for empty input we set default values
            if [[ -z $range ]]; then
                declare -g PORT_RANGE="8113-8311"
                declare -g MIN_PORT=8113
                declare -g MAX_PORT=8311
                return
            fi
            min_port=$(echo $range | cut -d- -f1 | sed 's/ *//g')
            max_port=$(echo $range | cut -d- -f2 | sed 's/ *//g')
            if $(is_number $min_port) && $(is_number $max_port); then
                declare -g PORT_RANGE="$range"
                declare -g MIN_PORT=$min_port
                declare -g MAX_PORT=$max_port
                return
            fi
        done
    elif [[ $mode == "unattended" ]]; then
        min_port=$(echo $PORT_RANGE | cut -d- -f1 | sed 's/ *//g')
        max_port=$(echo $PORT_RANGE | cut -d- -f2 | sed 's/ *//g')
        if $(is_number $min_port) && $(is_number $max_port); then
            declare -g MIN_PORT=$min_port
            declare -g MAX_PORT=$max_port
        else
            echo "[ERROR] invalid port"
        fi
    fi
}


function set_gs_additional_deploy_params() {
    print_menu_header "PARAMETERS" "Enter additional deployment parameters (ENTER to skip):"
    read -p "#? " extra_params
    [[ ! -z $extra_params ]] && declare -g DEPLOY_PARAMS="$extra_params"
}


function set_gs_options_ext() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "GS_OPTIONS_EXT" "Enter additional JVM options (ENTER to skip):"
        read -p "#? " ext_opt
        [[ ! -z $ext_opt ]] && declare -g GS_EXT=$ext_opt
    elif [[ $mode == "unattended" ]]; then
        if [[ ! -z $GS_EXT ]]; then
            GS_EXT=$(echo "$GS_EXT" | sed "s/\[ZONE\]/$ZONE/g")
            GS_EXT=$(echo "$GS_EXT" | sed "s/\[SERVICE\]/$SERVICE/g")
            GS_EXT=$(echo "$GS_EXT" | sed "s/\[SERVICE_NAME\]/$SERVICE_NAME/g")
        fi
    fi
}


function generate_custom_script() {
    if [[ ! -e $GEN_SCRIPT ]]; then
        echo '#!/bin/bash' > $GEN_SCRIPT
        echo -e "\n# $(basename $0) automated script\n" >> $GEN_SCRIPT
    fi
    echo "# service: $(basename ${SERVICE_PATH})" >> $GEN_SCRIPT
    echo -e "$(realpath $0) full -s ${SERVICE_PATH} -j ${JAR} -c ${NUM_OF_CONTAINERS} -m ${JVM_RAM} -i ${NUM_OF_INSTANCES} -p 8113-8311\n" >> $GEN_SCRIPT
    sleep 0.1
    echo "automated service '$SERVICE' complete."
}


function service_presets() {
    local opt=$1
    [[ ! -z $2 ]] && [[ $2 == "--silent" ]] && local silent=true || silent=false
    if [[ $opt == "init" ]]; then
        $silent || print_menu_header "REVIEW PRESETS" "Presets are available for selected service(s):"
        $silent || echo "[SERVICE NAME: $SERVICE]"
        if [[ ! -e $SERVICE_PATH/$SERVICE_PRESETS ]]; then
            echo "NUM_OF_CONTAINERS=1" > $SERVICE_PATH/$SERVICE_PRESETS
            echo "JVM_RAM=1g" >> $SERVICE_PATH/$SERVICE_PRESETS
            echo "NUM_OF_INSTANCES=1" >> $SERVICE_PATH/$SERVICE_PRESETS
            latest_jar=$(find $SERVICE_PATH -name "*jar*" | sort -rn | head -1)
            echo "JAR=$latest_jar" >> $SERVICE_PATH/$SERVICE_PRESETS
            echo "PORT_RANGE=8113-8311" >> $SERVICE_PATH/$SERVICE_PRESETS
        fi
        $silent || while read line; do echo "   $line" ; done < $SERVICE_PATH/$SERVICE_PRESETS
        $silent || while true; do
            unset answer
            echo ; read -p "Accept and proceed? [Y/n] " answer
            [[ -z $answer ]] && { declare -g USE_SERVICE_PRESETS=true ; break ; }
            case ${answer,,} in
                y*) declare -g USE_SERVICE_PRESETS=true ; break ;;
                n*) declare -g USE_SERVICE_PRESETS=false ; break ;;
                *) echo "invalid input. type 'Y' or 'n' or press ENTER" ;;
            esac
        done
    elif [[ $opt == "update" ]]; then
        [[ ! -z $NUM_OF_CONTAINERS ]] && [[ $NUM_OF_CONTAINERS != "" ]] && \
        sed -i "s/^NUM_OF_CONTAINERS=.*/NUM_OF_CONTAINERS=$NUM_OF_CONTAINERS/" $SERVICE_PATH/$SERVICE_PRESETS        
        [[ ! -z $JVM_RAM ]] && [[ $JVM_RAM != "" ]] && \
        sed -i "s/^JVM_RAM=.*/JVM_RAM=$JVM_RAM/" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $NUM_OF_INSTANCES ]] && [[ $NUM_OF_INSTANCES != "" ]] && \
        sed -i "s/^NUM_OF_INSTANCES=.*/NUM_OF_INSTANCES=$NUM_OF_INSTANCES/" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $JAR ]] && [[ $JAR != "" ]] && \
        sed -i "s|^JAR=.*|JAR=$JAR|" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $PORT_RANGE ]] && [[ $PORT_RANGE != "" ]] && \
        sed -i "s/^PORT_RANGE=.*/PORT_RANGE=$PORT_RANGE/" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $GS_EXT ]] && [[ $GS_EXT != "" ]] && {
            sed -i '/GS_EXT=/d' $SERVICE_PATH/$SERVICE_PRESETS
            echo "GS_EXT=$GS_EXT" >> $SERVICE_PATH/$SERVICE_PRESETS
        }
        [[ ! -z $DEPLOY_PARAMS ]] && [[ $DEPLOY_PARAMS != "" ]] && {
            sed -i '/DEPLOY_PARAMS=/d' $SERVICE_PATH/$SERVICE_PRESETS
            echo "DEPLOY_PARAMS=$DEPLOY_PARAMS" >> $SERVICE_PATH/$SERVICE_PRESETS
        }
    elif [[ $opt == "set" ]]; then
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "NUM_OF_CONTAINERS=")
        [[ $test != "" ]] && declare -g NUM_OF_CONTAINERS=$(echo "$test" | grep "NUM_OF_CONTAINERS=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "JVM_RAM=")
        [[ $test != "" ]] && declare -g JVM_RAM=$(echo "$test" | grep "JVM_RAM=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "NUM_OF_INSTANCES=")
        [[ $test != "" ]] && declare -g NUM_OF_INSTANCES=$(echo "$test" | grep "NUM_OF_INSTANCES=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "JAR=")
        [[ $test != "" ]] && declare -g JAR=$(echo "$test" | grep "JAR=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "PORT_RANGE=")
        [[ $test != "" ]] && declare -g PORT_RANGE=$(echo "$test" | grep "PORT_RANGE=" | cut -d= -f2-) && set_port_range unattended
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "GS_EXT=")
        [[ $test != "" ]] && declare -g GS_EXT=$(echo "$test" | grep "GS_EXT=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "DEPLOY_PARAMS=")
        [[ $test != "" ]] && declare -g DEPLOY_PARAMS=$(echo "$test" | grep "DEPLOY_PARAMS=" | cut -d= -f2-)
    fi
}


function update_defaults() {
    
    function change_presets_param() {
        local key=$1
        local value=$2
        find $SERVICES_DIR -mindepth 1 -maxdepth 1 -type d | while read d; do
            SERVICE_PATH="$d"
            get_services unattended
            #[[ ! -e $SERVICE_PATH/$SERVICE_PRESETS ]] && service_presets init --silent
            service_presets init --silent
            sed -i "s/$key=.*/$key=$value/" $SERVICE_PATH/$SERVICE_PRESETS
        done
    }

    declare -a params=("Number of Instances" "JVM Memory" "Number of Containers")    
    print_menu_header "PARAMETERS" "Choose one or more parameters(s) you want to change:"
    print_menu_items --in params[@] --out user_selections -m

    for index in ${user_selections[@]}; do
        case $index in
            1)  get_num_of_instances interactive
                change_presets_param NUM_OF_INSTANCES $NUM_OF_INSTANCES ;;
            2)  get_memory_allocation interactive
                change_presets_param JVM_RAM $JVM_RAM ;;
            3)  get_num_of_containers interactive
                change_presets_param NUM_OF_CONTAINERS $NUM_OF_CONTAINERS ;;
        esac
    done
}


function list_current_service_presets() {
    local presets="  "
    for s in ${AVAILABLE_SERVICES[@]}; do
        echo
        echo "[ $s ]"
        local c=$(grep "CONTAINERS" $SERVICES_DIR/$s/$SERVICE_PRESETS)
        local j=$(grep "JVM" $SERVICES_DIR/$s/$SERVICE_PRESETS)
        local i=$(grep "INSTANCES" $SERVICES_DIR/$s/$SERVICE_PRESETS)
        echo "    ${c}, ${j}, ${i}"
    done
}


function list_services() {
    local uri="http://${MANAGER}:8090/v2/pus"
    local deployed_services=""
    local available_services=""
    declare -A all_services
    
    # create list of deployed services
    while read -r ds; do
        deployed_services+="${ds} "
    done < <(curl -sk -u "$AUTH_USER:$AUTH_PASS" $uri | jq -r '.[] | select(.processingUnitType == "stateless") | .name' | grep "_service$" | sed 's/ //g')
    deployed_services=$(echo $deployed_services | sed 's/ $//')

    # create list of available services
    for s in ${AVAILABLE_SERVICES[@]}; do
        s_name="$(echo $s | tr '[:upper:]' '[:lower:]')_service"
        available_services+="$s_name "
    done
    available_services=$(echo $available_services | sed 's/ $//')

    for ds in $deployed_services; do
        if [[ "$available_services" == *"$ds"* ]] ; then
            all_services[$ds]="deployed:available"
        else
            all_services[$ds]="deployed:unavailable"
        fi
    done

    for as in $available_services; do
        if [[ "$deployed_services" == *"$as"* ]] ; then
            continue
        else
            all_services[$as]="undeployed:available"
        fi
    done

     echo
    printf "%-40s | %-12s | %-18s\n" "Service Name" "Is Deployed" "Available in GCOM"
    printf '‾%.0s' {1..75} ; echo
    for key in ${!all_services[@]}; do
        if [[ "$(echo ${all_services["$key"]} | cut -d: -f1)" == "deployed" ]] ; then
            remote="YES"
        else
            remote="NO"
        fi
        if [[ "$(echo ${all_services["$key"]} | cut -d: -f2)" == "available" ]] ; then
            local="YES"
        else
            local="NO"
        fi
        printf "%-40s   %-12s   %-18s\n" "$key" "$remote" "$local"
    done
    printf '_%.0s' {1..75} ; echo
    echo
}


function undeploy_pu() {
    # try to set JAVA_HOME
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi
    logger $LOG $GS_EXEC --username $AUTH_USER --password $AUTH_PASS service undeploy $SERVICE_NAME
}


function kill_containers() {
    # try to set JAVA_HOME
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi
    logger $LOG $GS_EXEC --username $AUTH_USER --password $AUTH_PASS container kill --zones=$ZONE
}


function create_containers() {
    # abort if no mem info found
    if [[ ${#SPACE_MEM_INFO[@]} == 0 ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] no space hosts memory info found." >> $LOG
        return
    fi
    
    # set JAVA_HOME if java is installed
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi

    local count=0
    declare -A runtime_mem_info
    
    # create a duplicate runtime array from SPACE_MEM_INFO
    for k in "${!SPACE_MEM_INFO[@]}"; do runtime_mem_info["$k"]="${SPACE_MEM_INFO[$k]}" ; done

    while [[ $count -lt $NUM_OF_CONTAINERS ]]; do
        if [[ $count -ge $NUM_OF_SPACES ]] && [[ $(expr $count % $NUM_OF_SPACES) -eq 0 ]]; then
            # reset runtime array back when count is reached
            for k in "${!SPACE_MEM_INFO[@]}"; do runtime_mem_info["$k"]="${SPACE_MEM_INFO[$k]}" ; done
        fi
        local optimal_host=$(get_max_free_mem_host runtime_mem_info)
        logger $LOG $GS_EXEC --username $AUTH_USER --password $AUTH_PASS container create --count=1 --memory=$JVM_RAM --zone=$ZONE $optimal_host
        unset runtime_mem_info["$optimal_host"]       # removing last used host from the list
        ((count++))
    done    
}


function deploy_pu() {
    # try to set JAVA_HOME
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi

    [[ ! -z $DEPLOY_PARAMS ]] && \
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] adding additional deploy parameters: $DEPLOY_PARAMS" >> $LOG
    if [[ ! -z $GS_EXT ]]; then
        export GS_OPTIONS_EXT="$GS_EXT"
        echo "$(date '+%Y-%m-%d %H:%M:%S') [EXEC] export GS_OPTIONS_EXT=$GS_EXT" >> $LOG
    fi
    
    logger $LOG $GS_EXEC --username $AUTH_USER --password $AUTH_PASS service deploy $SERVICE_NAME \
    --instances=$NUM_OF_INSTANCES --zones=$ZONE $DEPLOY_PARAMS \
    -p minPort=$MIN_PORT -p maxPort=$MAX_PORT -p consul.host=localhost $JAR
}


function full_deployment_routine() {
    local mode=$1
    if [[ $mode == "interactive" ]] ; then
        service_presets init
        $USE_SERVICE_PRESETS && service_presets set
    elif [[ $mode == "unattended" ]] ; then
        get_services $mode
        USE_SERVICE_PRESETS=false
    fi
    if ! $USE_SERVICE_PRESETS ; then
        get_num_of_containers $mode
        get_memory_allocation $mode
        get_num_of_instances $mode
        get_jar_file $mode
        [[ $mode == "interactive" ]] && JAR="${SERVICE_PATH}/${AVAILABLE_JARS[$((${user_selections[0]}-1))]}"
        set_port_range $mode
        [[ $mode == "interactive" ]] && set_gs_additional_deploy_params
        set_gs_options_ext $mode
        if [[ $mode == "interactive" ]] ; then
            service_presets $mode
            print_gs_logo
        fi
    fi
    $VERBOSE && print_vars
    echo -e "\nInitializing $action_name for service: '$SERVICE' ..."
    undeploy_pu
    kill_containers
    create_containers
    deploy_pu
}


function create_containers_routine() {
    local mode=$1
    if [[ $mode == "interactive" ]] ; then
        service_presets init
        $USE_SERVICE_PRESETS && service_presets set
    elif [[ $mode == "unattended" ]] ; then
        get_services $mode
        USE_SERVICE_PRESETS=false
    fi
    if ! $USE_SERVICE_PRESETS ; then
        get_num_of_containers $mode
        get_memory_allocation $mode
        if [[ $mode == "interactive" ]] ; then
            service_presets $mode
            print_gs_logo
        fi
    fi
    $VERBOSE && print_vars
    echo -e "\nInitializing $action_name for service: '$SERVICE' ..."
    create_containers
}


function deploy_pu_routine() {
    local mode=$1
    if [[ $mode == "interactive" ]] ; then
        service_presets init
        $USE_SERVICE_PRESETS && service_presets set
    elif [[ $mode == "unattended" ]] ; then
        get_services $mode
        USE_SERVICE_PRESETS=false
    fi
    if ! $USE_SERVICE_PRESETS ; then
        get_num_of_instances $mode
        get_jar_file $mode
        [[ $mode == "interactive" ]] && JAR="${SERVICE_PATH}/${AVAILABLE_JARS[$((${user_selections[0]}-1))]}"
        set_port_range $mode
        [[ $mode == "interactive" ]] && set_gs_additional_deploy_params
        set_gs_options_ext $mode
        if [[ $mode == "interactive" ]] ; then
            service_presets $mode
            print_gs_logo
        fi
    fi
    $VERBOSE && print_vars
    echo -e "\nInitializing $action_name for service: '$SERVICE' ..."
    deploy_pu
}


function kill_containers_routine() {
    local mode=$1
    if [[ $mode == "interactive" ]] ; then
        print_gs_logo
    elif [[ $mode == "unattended" ]] ; then
        get_services $mode
    fi
    $VERBOSE && print_vars
    echo -e "\nInitializing $action_name for service: '$SERVICE' ..."
    kill_containers
}


function undeploy_pu_routine() {
    local mode=$1
    if [[ $mode == "interactive" ]] ; then
        print_gs_logo
    elif [[ $mode == "unattended" ]] ; then
        get_services $mode
    fi
    $VERBOSE && print_vars
    echo -e "\nInitializing $action_name for service: '$SERVICE' ..."
    undeploy_pu
}


#
# # # MAIN # # #
#

VERBOSE=false
UNATTENDED=false
BASH_REQUIRED=4.4
GS_ROOT=/dbagiga
export GS_HOME="$GS_ROOT/gigaspaces-smart-ods"
GS_LOG_ROOT=/dbagigalogs
GS_EXEC=$GS_HOME/bin/gs.sh
LOG=${GS_LOG_ROOT}/$(basename $0).log
BASE_DIR=$(dirname $(realpath $0))
SERVICES_DIR=${BASE_DIR}/services
SERVICE_PRESETS="service.presets"
declare -A SPACE_MEM_INFO
declare -a SERVICES_PATHS
GEN_SCRIPT="/tmp/$(basename $0)_autogen_$(date '+%Y%m%d')-$RANDOM.sh"
PREREQUISITES="jq"  # space separated commands

# text styles
_b=$(tput bold)     # bold text
_nb=$(tput sgr0)    # not bold text
_r='\033[0;31m'     # red text
_lr='\033[1;31m'    # light red text
_g='\033[0;32m'     # green text
_lg='\033[1;32m'    # light green text
_o='\033[0;33m'     # orange text
_y='\033[1;33m'     # yellow text
_b='\033[0;34m'     # blue text
_lb='\033[1;34m'    # light blue text
_p='\033[0;35m'     # purple text
_lp='\033[1;35m'    # light purple text
_c='\033[0;36m'     # cyan text
_lc='\033[1;36m'    # light cyan text
_w='\033[0;37m'     # white text
_res='\033[0m'      # no colour



declare -A menu_items=(
    [1]="name=Deployment,type=menu,exec=,desc=Execute deployment operations"
        [1.1]="name=Full Deployment,type=action,exec=full_deployment_routine,desc=Run complete deployment"
        [1.2]="name=Undeploy PU,type=action,exec=undeploy_pu_routine,desc=Undeploy a PU only"
        [1.3]="name=Create Containers,type=action,exec=create_containers_routine,desc=Create containers only"
        [1.4]="name=Kill Containers,type=action,exec=kill_containers_routine,desc=Remove containers only"
        [1.5]="name=Deploy PU,type=action,exec=deploy_pu_routine,desc=Deploy a PU only"
    [2]="name=Information,type=menu,exec=,desc=Get DIH information"
        [2.1]="name=List Resources,type=action,exec=list_resources,desc=List space resource distribution"
        [2.2]="name=List Services,type=action,exec=list_services,desc=List deployed and available services"
        [2.3]="name=List Service Presets,type=action,exec=list_current_service_presets,desc=List service presets"
    [3]="name=Configuration,type=menu,exec=,desc=Configure gcom"
        [3.1]="name=Update Defaults,type=action,exec=update_defaults,desc=Change gcom default configuration"
    [4]="name=Tools,type=menu,exec=,desc=Additional gcom tools and utilities"
        [4.1]="name=Script Generator,type=action,exec=generate_custom_script,desc=Generate a full deployment gcom script"
)


# # # MAIN # # #

while [[ $# -gt 0 ]]; do
    case $1 in
        full|create|deploy|kill|undeploy|list|fd-gen) cmd=$1 ; UNATTENDED=true ;;
        version) echo $VERSION && exit 0 ;;
        -s) shift ; SERVICES_PATHS+=("$(realpath $(echo $1 | sed 's|/$||'))") ;;
        -c) shift ; NUM_OF_CONTAINERS=$1 ;;
        -m) shift ; JVM_RAM=$1 ;;
        -i) shift ; NUM_OF_INSTANCES=$1 ;;
        -j) shift ; JAR="$1" ;;
        -p) shift ; PORT_RANGE="$1" ;;
        -x) shift ; DEPLOY_PARAMS="$1" ;;
        -o) shift ; GS_EXT="$1" ;;
        -v) VERBOSE=true ;;
        -h*) usage ; exit ;;
        *) usage ; exit ;;
    esac
    shift
done

if $VERBOSE ; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] verbose mode: ON" >> $LOG
else
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] verbose mode: OFF" >> $LOG
fi

# check prerequisites
prereqs_ok=true
# bash version
if ! bash_version_ok; then
    prereqs_ok=false
    echo "[ERROR] incompatible BASH version. must be ${BASH_REQUIRED} or above."
fi
for package in $PREREQUISITES; do
    if ! command -v $package &> /dev/null; then
        prereqs_ok=false
        echo "[ERROR] missing prerequisite '$package'."
    fi
done
$prereqs_ok || exit 1

# check host.yaml exists
if [[ ! -e ${ENV_CONFIG}/host.yaml ]]; then
    logger $LOG echo "[ERROR] host.yaml not found. aborting!"
    exit
fi

# check folder structure
if [[ ! -d $SERVICES_DIR ]]; then
    mkdir $SERVICES_DIR
    echo
    logger $LOG echo "[INFO] 'services' folder not found. created it."
    logger $LOG echo "[INFO] put all service folders in it."
    echo
    exit
fi
if [[ $(find $SERVICES_DIR -mindepth 1 -maxdepth 1 -type d | wc -l) == 0 ]]; then
    echo
    logger $LOG echo "[WARNING] no data found in 'services' folder. nothing to deploy"
    exit
else
    # generate a list of available services
    AVAILABLE_SERVICES=($(find $SERVICES_DIR -mindepth 1 -maxdepth 1 -type d | sed "s|${SERVICES_DIR}/||"))
fi

# get credentials if env is secured
get_auth

# get manager host
for m in $(get_cluster_hosts "manager"); do is_manager_rest_ok $m && MANAGER=$m && break ; done
if [[ -z $MANAGER ]]; then
    echo
    logger $LOG echo "[ERROR] no avaialable managers found!"
    exit
fi

# get space memory information
mem_used_per_space_host
echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] space info acquired" >> $LOG

# get number of space servers
NUM_OF_SPACES=$(get_cluster_hosts space | wc -w)

if $UNATTENDED; then
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] mode: unattended" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] command: '$cmd'" >> $LOG
    [[ $cmd == "list" ]] && list_resources && exit
    [[ $cmd == "version" ]] && echo "$VERSION" && exit
    for ((i=0; i<${#SERVICES_PATHS[@]}; i++)); do
        SERVICE_PATH="${SERVICES_PATHS[$i]}"
        case $cmd in
            "full")
                full_deployment_routine unattended ;;
            "create")
                create_containers_routine unattended ;;
            "deploy")
                deploy_pu_routine unattended ;;
            "kill")
                kill_containers_routine unattended ;;
            "undeploy")
                undeploy_pu_routine unattended ;;
        esac
    done
else
    # if service perameter exists but no command is set
    if [[ ${#SERVICES_PATHS[@]} -gt 0 ]]; then
        logger $LOG echo "[ERROR] missing command. use -h for help."
        exit
    fi
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] mode: interactive" >> $LOG
    declare -a wizard_selections=()
    declare -a user_selections=()
    while true; do
        action_name=""
        action_type=""
        exec_action=""
        abort_script_generator=false

        print_gs_logo
        menu_builder    # generate current_menu_names[@]
        print_menu_items --in current_menu_names[@] --out wizard_selections --desc current_menu_descriptions[@] -a

        # check selection type
        if [[ ${#wizard_selections[@]} != 0 ]] ; then
            selected_params="${menu_items[$(echo ${wizard_selections[@]} | sed 's/ /./g')]}"
            action_name=$(echo $selected_params | cut -d, -f1 | cut -d= -f2)
            action_type=$(echo $selected_params | cut -d, -f2 | cut -d= -f2)
            exec_action=$(echo $selected_params | cut -d, -f3 | cut -d= -f2)
        fi
        
        if [[ $action_type == "action" ]]; then
            echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] command: '$action_name'" >> $LOG
            case $exec_action in
                "list_resources"|\
                "list_current_service_presets"|\
                "update_defaults"|\
                "list_services")
                    $exec_action
                    unset wizard_selections[$((${#wizard_selections[@]} - 1))]
                    pause ; echo
                    continue
                    ;;
            esac
            if [[ $exec_action == "generate_custom_script" ]]; then
                print_gs_logo
                print_menu_header "SCRIPT GENERATOR" "Generate unattended execution script"
                echo -e "[NOTE]\n"
                echo "A single script will be generated for selected service(s)."
                echo "Only default parameters will be used for services."
                while true; do
                    unset answer
                    read -p "Proceed? [Y/n] " answer
                    [[ -z $answer ]] && answer=y
                    case ${answer,,} in
                        y*) break ;;
                        n*) abort_script_generator=true ; break ;;
                        *) echo "invalid input. type 'Y' or 'n' or press ENTER" ;;
                    esac
                done
                if ! $abort_script_generator ; then
                    echo -e "\n\nReset defaults for all services before generation (Recommended)?"
                    while true; do
                        unset answer
                        read -p "Proceed? [Y/n] " answer
                        [[ -z $answer ]] && answer=y
                        case ${answer,,} in
                            y*) update_defaults ; break ;;
                            n*) break ;;
                            *) echo "invalid input. type 'Y' or 'n' or press ENTER" ;;
                        esac
                    done
                fi
            fi
            if $abort_script_generator ; then
                unset wizard_selections[$((${#wizard_selections[@]} - 1))]
                continue
            fi
            # excute operations for selected service(s)
            if [[ $exec_action == "generate_custom_script" ]]; then
                get_services interactive "SCRIPT GENERATOR"
            else
                get_services interactive SERVICES
            fi
            for index in ${user_selections[@]}; do
                SERVICE_PATH="$SERVICES_DIR/${AVAILABLE_SERVICES[$((index-1))]}"
                SERVICE=$(echo $(basename "$SERVICE_PATH") | tr '[:upper:]' '[:lower:]')
                ZONE=$SERVICE
                SERVICE_NAME="${SERVICE}_service"
                if [[ $exec_action == "generate_custom_script" ]]; then
                    service_presets init --silent
                    service_presets set
                    generate_custom_script
                else
                    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] selected service: '$SERVICE'" >> $LOG
                    AVAILABLE_JARS=($(find $SERVICE_PATH -mindepth 1 -maxdepth 1 -type f -name "*.jar" -exec basename {} \;))
                    $exec_action "interactive"
                    pause ; echo
                fi
            done
            unset wizard_selections[$((${#wizard_selections[@]} - 1))]
            # post execution
            if [[ $exec_action == "generate_custom_script" ]]; then
                echo -e "\n\n* Automated script generated as '$GEN_SCRIPT'\n"
                pause ; echo
            fi
        fi
    done
fi

exit
