#!/bin/bash

# GENERAL:
#   gcom - Gigaspaces Components Orchestration Manager
# 
# DESCRIPTION:
#   supports unattended or interactive gs component deployment

VERSION=0.1.0

function usage() {
cat << EOF

$(basename $0) version $VERSION
Copyright (C) 2023 Gigaspace Inc. by Alon Segal.

USAGE:
    interactive: $(basename $0)
    or
    unattended:  $(basename $0) [Commands] [Options]

DESCRIPTION:
    * microservices deployment operations (multiple selection supported)
    * interactive 'wizard-like' mode using presets to streamline executions
    * unattended mode for full automation
    * choose between complete deployment or selected operations for a more granular control of execution
    * supports multi-instance deployments with smart container distribution across grid space nodes

COMMANDS:
    full        Complete service deployment - execute all commands.
    create      Create containers for a service
    deploy      Deploy a processing unit
    kill        Delete containers
    undeploy    Undeploy a processing unit
    list        List space resources accross hosts
    version     Show version

OPTIONS:
    -s          Path to the service
    -j          Jar file to deploy
    -c          Total number of containers to create
    -m          Memory allocation size (human readable e.g. 512m, 2g)
    -i          Number of instances
    -v          Increase verbosity
    -x          Enter additional pu deployment parameters
    -p          Specify port range (format: 1000-1200)
    -o          Supply additional JVM options for deploy stage
                Supported placeholders:
                    * [ZONE] - the zone name
                    * [SERVICE] - same as zone name
                    * [SERVICE_NAME] - the value of [SERVICE] with the '_service' suffix
                    * [JAR] - the full path to the jar file
                    * [JVM_RAM] - the allocated memory size in human readable format (e.g. 512m, 2g)
    -h,--help   Show usage

EXAMPLES:
    unattended full deployment
        $(basename $0) full -s <SERVICE_PATH> -c <NUM_OF_CONTAINERS> -m <JVM_RAM> -i <NUM_OF_INSTANCES> -j <JAR_PATH>
    
    unattended undeploy pu only
        $(basename $0) undeploy -s <SERVICE_PATH>
    
    unattended kill containers only
        $(basename $0) kill -s <SERVICE_PATH>
    
    unattended create containers only
        $(basename $0) create -s <SERVICE_PATH> -c <NUM_OF_CONTAINERS> -m <JVM_RAM>
    
    unattended deploy pu only
        $(basename $0) deploy -s <SERVICE_PATH> -i <NUM_OF_INSTANCES> -j <JAR_PATH> 
    
    unattended deploy pu only with additional options GS_OPTIONS_EXT using placeholder [ZONE]
        $(basename $0) deploy -s <SERVICE_PATH> -i <NUM_OF_INSTANCES> -j <JAR_PATH> -o "-Xlog:gc*:file=/tmp/[ZONE]_gc_%p.log:time,level"
    * [ZONE] placeholder for -Xlog:gc*:file will be replaced with the appropriate value during runtime

EOF
}

function bash_version_ok() {
    local this_version=$(echo $BASH_VERSION | cut -d. -f1-2)
    [[ $(echo "$this_version >= $BASH_REQUIRED" | bc -l) == 1 ]] && return 0 || return 1
}

function print_gs_logo() {
    clear ; clear
    printf '#%.0s' {1..63} ; echo                       # line 1
    echo -n "#" ; printf ' %.0s' {1..61} ; echo "#"     # line 2
    echo -n "#" ; printf ' %.0s' {1..6}                 # line 3
    echo -n -e "${_lr}*${_res} ${_lg}/${_res} * "       # line 3
    printf ' %.0s' {1..49} ; echo "#"                   # line 3
    echo -n "#" ; printf ' %.0s' {1..3}                             # line 4
    echo -n -e "${_lb}/${_res} ${_lr}/${_res} ${_lg}/${_res} / * "  # line 4
    printf ' %.0s' {1..18} ; echo -n "- G.C.O.M -"                  # line 4
    printf ' %.0s' {1..19} ; echo "#"                               # line 4
    echo -n -e "#  / ${_o}/${_res} ${_lg}/${_res} ${_b}/${_res} ${_b}/${_res}"     # line 5
    echo -n "    Gigaspaces Components Orchestration Manager"                       # line 5
    printf ' %.0s' {1..3} ; echo "#"                                               # line 5
    echo -n "#" ; printf ' %.0s' {1..3}                                     # line 6
    echo -n -e "${_o}/${_res} ${_b}/${_res} ${_b}/${_res} ${_b}*${_res}"    # line 6
    printf ' %.0s' {1..51} ; echo "#"                                       # line 6
    echo -n "#" ; printf ' %.0s' {1..61} ; echo "#"     # line 7
    printf '#%.0s' {1..63} ; echo                       # line 8
}

function print_menu_header() {
    local key="$1"
    local header="$2"
    local line="$key $header"
    local length=$(expr ${#line} + 6)
    printf "\n:: ${key} :: ${header}\n"
    printf '‾%.0s' $(seq "$length")
    printf "\n"
}

function print_menu_items() {
    # user choices are added to global array 'menu_choices'
    # as indexes for global array 'services'
    declare -ga menu_choices=()

    # set operation mode single | multi select
    [[ -z $1 ]] && echo "invalid function call" && return
    local mode=$1

    # list of menu items
    [[ -z $2 ]] && echo "invalid function call" && return
    local items=("${!2}")

    function is_a_valid_menu_number() {
        local user_input=$1
        local max_items=$2
        if [[ "$user_input" =~ ^[0-9]+$ ]]; then
            if [[ $user_input -lt 1 ]] || [[ $user_input -gt $max_items ]]; then
                echo false
            else
                echo true
            fi
        else
            echo false
        fi
    }

    function is_a_valid_menu_range() {
        # check if input is a valid range (e.g. 1-4)
        local user_input=$1
        local max_items=$2
        if [[ "$user_input" == *"-"* ]]; then
            min_val=$(echo $user_input | cut -d- -f1)
            max_val=$(echo $user_input | cut -d- -f2)
            $(is_a_valid_menu_number $min_val $max_items) && \
            $(is_a_valid_menu_number $max_val $max_items) && \
            echo true || echo false
        else
            echo false
        fi
    }

    # print the menu
    for ((i=0; i<${#items[@]}; i++)); do
        echo "[$((i+1))] ${items[$i]}"
    done

    if [[ $mode == 'single' ]]; then
        while true; do
            read -p "#? " num
            if $(is_a_valid_menu_number $num ${#items[@]}); then
                menu_choices+=($((num-1)))
                break
            else
                echo "invalid input! select between 1-${#items[@]}"
            fi
        done
    elif [[ $mode == 'multiple' ]]; then
        input_valid=false
        until $input_valid; do
            read -p "#? " choice
            inputs=$(echo $choice | sed 's/ *//g;s/,/ /g')  # convert to list
            for i in $inputs; do
                if $(is_a_valid_menu_range $i ${#items[@]}); then
                    local min_val=$(echo $i | cut -d- -f1)
                    local max_val=$(echo $i | cut -d- -f2)
                    # correct inverted range
                    if [[ $min_val -gt $max_val ]]; then
                        local t=$min_val; min_val=$max_val ; max_val=$t
                    fi
                    for n in $(eval echo {$min_val..$max_val}); do
                        menu_choices+=($((n-1)))
                    done
                    input_valid=true
                    continue
                elif $(is_a_valid_menu_number $i ${#items[@]}); then
                    menu_choices+=($((i-1)))
                    input_valid=true
                    continue
                else
                    echo "invalid input! select between 1-${#items[@]}"
                    input_valid=false
                    break
                fi
            done
        done
    fi
}

function print_vars() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] MANAGER set to: $MANAGER" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] NUM OF SPACES set to: $NUM_OF_SPACES" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] SERVICE_PATH set to: $SERVICE_PATH" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] SERVICE | ZONE set to: $SERVICE" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] SERVICE_NAME set to: $SERVICE_NAME" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] NUM_OF_CONTAINERS set to: $NUM_OF_CONTAINERS" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] JVM_RAM set to: $JVM_RAM" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] PORT_RANGE set to: $PORT_RANGE" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] NUM_OF_INSTANCES set to: $NUM_OF_INSTANCES" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] JAR set to: $JAR" >> $LOG
    if [[ ! -z $DEPLOY_PARAMS ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] DEPLOY_PARAMS set to: $DEPLOY_PARAMS" >> $LOG
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] DEPLOY_PARAMS not set" >> $LOG
    fi
    if [[ ! -z $GS_EXT ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] GS_EXT set to: $GS_EXT" >> $LOG
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] GS_EXT not set" >> $LOG
    fi
}


function logger() {
    local log_file="$1"
    local cmd="${@:2}"

    { $cmd 2>&1 | \
    tee >(while read -r line; do 
            echo "$(date '+%Y-%m-%d %H:%M:%S') $line";
        done >> "$log_file"); } 2>&1
}

function print_mem_size_human() {
    local num=$1
    local d=1000    # common devider
    local deviders=( $d $(($d**2)) $(($d**3)) )
    local units=( "KB" "MB" "GB" )

    for ((i=0; i<${#deviders[*]}; i++)); do
        if [[ $(expr $num / ${deviders[$i]}) -lt 1000 ]]; then
            echo "$(echo "scale=2 ; $num / ${deviders[$i]}" | bc) ${units[$i]}"
            break
        fi
    done
}

function is_number() {
    local input="$1"
    [[ "$input" =~ ^[0-9]+$ ]] && echo true || echo false
}

function get_cluster_hosts {
    local cluster_name=$1
    local prefix=$2
    local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
    sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" \
        ${ENV_CONFIG}/host.yaml |
    awk -F$fs '{
        indent = length($1)/2;
        vname[indent] = $2;
        for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=\"%s\"\n", "'$prefix'",vn, $2, $3);
        }
    }' | while read line; do
        [[ "$line" =~ .*"${cluster_name}_host".* ]] && \
        echo $line | sed 's/ *//g' | sed 's/"//g' | cut -d= -f2
    done
}

function get_auth() {
    sec_flag=$(cat ${ENV_CONFIG}/app.config | grep "app.setup.profile" | cut -d= -f2)
    if [[ $sec_flag != "" ]]; then
        declare -g AUTH_USER=$(cat ${ENV_CONFIG}/app.config | grep "app.manager.security.username" | cut -d= -f2)
        declare -g AUTH_PASS=$(cat ${ENV_CONFIG}/app.config | grep "app.manager.security.password" | cut -d= -f2)
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] environment secured. extracted username/password from app.config" >> $LOG
    else
        declare -g AUTH_USER=""
        declare -g AUTH_PASS=""
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] environment not secured. username/password not set" >> $LOG
    fi
}
    
function is_manager_rest_ok() {
    local the_manager=$1
    local port_ok=false
    local rest_ok=false

    # check port
    nc -z $m 8090 && port_ok=true
    
    # check rest
    local rest="http://${the_manager}:8090/v2/index.html"
    local status_code=$(curl -u "$AUTH_USER:$AUTH_PASS" \
    --write-out '%{http_code}' --silent --output /dev/null "$rest")
    [[ $status_code -eq 200 ]] && rest_ok=true
    
    ($port_ok && $rest_ok) && return 0 || return 1
}

function list_resources() {
    local uri="http://${MANAGER}:8090/v2/containers"
    echo
    printf "%-20s | %-12s | %-10s | %-10s | %-12s\n" "Hostname" "IP" "Containers" "Total RAM" "Available RAM"
    printf '‾%.0s' {1..77} ; echo
    while read -r line; do
        h_name=$(echo $line | awk '{print $2}' | sed 's/ //g')
        h_ip=$(nslookup $h_name | grep 'Address' | awk 'NR==2 {print $2}' | sed 's/ //g')
        cont=$(echo $line | awk '{print $1}' | sed 's/ //g')
        tmem=$(print_mem_size_human $(echo ${SPACE_MEM_INFO["$h_ip"]} | sed -n 's/.*MemTotal=\([^,]*\).*/\1/p'))
        amem=$(print_mem_size_human $(echo ${SPACE_MEM_INFO["$h_ip"]} | sed -n 's/.*MemAvailable=\([^,]*\).*/\1/p'))
        printf "%-20s   %-12s   %-10s   %-10s   %-12s\n" "$h_name" "$h_ip" "$cont" "$tmem" "$amem"
    done < <(curl -sk -u "$AUTH_USER:$AUTH_PASS" $uri | jq -r '.[].id' | sed 's/~.*//g' | sort | uniq -c | sed 's/^ *//')
    printf '_%.0s' {1..77} ; echo
    echo
}

function mem_used_per_space_host() {
    # build a global meminfo dictionary for each space host
    # format: [host]:['MemTotal=KB_VAL,MemAvailable=KB_VAL']
    space_hosts=$(get_cluster_hosts space)
    
    # loop using free instead of /proc/meminfo
    for h in $space_hosts; do
        info=$(ssh "$h" 'free -b' | awk 'NR==2 {printf "MemTotal=%s,MemAvailable=%s", $2, $4}')
        SPACE_MEM_INFO["$h"]="$info"
    done
}

function get_max_free_mem_host() {
    declare -n free_mem_array="$1"
    local optimal_host=""
    local max_free=""

    for h in ${!free_mem_array[*]}; do
        current=$(echo ${free_mem_array[$h]} | sed -n 's/.*MemAvailable=\([^,]*\).*/\1/p')
        if [[ $current -gt $max_free ]]; then
            max_free=$current
            optimal_host=$h
        fi
    done
    echo $optimal_host
}

function warn_incompatible_ram_allocation() {
    # calculate the amount of total requested RAM per host against 
    # the available RAM per host to see if RAM is available
    echo "calculating ..."
}

function get_services() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "SERVICES" "Choose service(s) from the list:"
        print_menu_items multiple AVAILABLE_SERVICES[@]
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $SERVICE_PATH ]]; then
            echo -e "\n[ERROR] missing path to service. use -h for help."
            exit 1
        elif [[ ! -d $SERVICE_PATH ]]; then
            echo -e "\n[ERROR] service not found or invalid path."
            exit 1
        fi
    declare -g SERVICE=$(echo $(basename "$SERVICE_PATH") | tr '[:upper:]' '[:lower:]')
    declare -g ZONE=$SERVICE
    declare -g SERVICE_NAME="${SERVICE}_service"
    fi
}

function get_num_of_instances() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "INSTANCES" "How many instances of the service to deploy?"
        while true; do
            read -p "#? " res
            [[ "$res" =~ ^[0-9]+$ ]] && [[ "$res" -gt 0 ]] && break
            echo "Invalid input!"
        done
        declare -g NUM_OF_INSTANCES=$res
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $NUM_OF_INSTANCES ]]; then
            echo -e "\n[ERROR] number of instances not set. use -h for help."
            exit 1
        fi
    fi
}

function get_num_of_containers() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "CONTAINERS" "Enter how many containers to create for this service:"
        while true; do
            read -p "#? " res
            [[ "$res" =~ ^[0-9]+$ ]] && [[ "$res" -gt 0 ]] && break
            echo "Invalid input!"
        done
        declare -g NUM_OF_CONTAINERS=$res
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $NUM_OF_CONTAINERS ]]; then
            echo -e "\n[ERROR] number of containers not set. use -h for help."
            exit 1
        fi
    fi
    declare -g TOTAL_NUM_OF_CONTAINERS=$(expr $NUM_OF_CONTAINERS \* $NUM_OF_SPACES)
}

function get_memory_allocation() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "MEMORY" "How much RAM to allocate for each container [e.g. 512m or 1g]:"
        while true; do
            read -p "#? " res
            [[ "$res" =~ [mg] ]] && [[ "$( echo $res | sed 's/[mg]//')" =~ ^[0-9]+$ ]] && break
            echo "Invalid input!"
        done
        declare -g JVM_RAM=$res
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $JVM_RAM ]]; then
            echo -e "\n[ERROR] memory allocation size not set. use -h for help."
            exit 1
        fi
    fi
}

function get_jar_file() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "RESOURCE" "Select a jar file for deployment(s):"
        print_menu_items single AVAILABLE_JARS[@]
    fi
    if [[ $mode == "unattended" ]]; then
        if [[ -z $JAR ]]; then
            echo -e "\n[ERROR] missing path to jar file. use -h for help."
            exit 1
        elif [[ ! -e $JAR ]]; then
            echo -e "\n[ERROR] jar file not found or invalid path."
            exit 1
        fi
    fi
}

function set_port_range() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "PORTS" "Specify a port range (default: 8113-8311):"
        while true; do
            read -p "#? " range
            # for empty input we set default values
            if [[ -z $range ]]; then
                declare -g PORT_RANGE="8113-8311"
                declare -g MIN_PORT=8113
                declare -g MAX_PORT=8311
                return
            fi
            min_port=$(echo $range | cut -d- -f1 | sed 's/ *//g')
            max_port=$(echo $range | cut -d- -f2 | sed 's/ *//g')
            if $(is_number $min_port) && $(is_number $max_port); then
                declare -g PORT_RANGE="$range"
                declare -g MIN_PORT=$min_port
                declare -g MAX_PORT=$max_port
                return
            fi
        done
    fi
    min_port=$(echo $PORT_RANGE | cut -d- -f1 | sed 's/ *//g')
    max_port=$(echo $PORT_RANGE | cut -d- -f2 | sed 's/ *//g')
    if $(is_number $min_port) && $(is_number $max_port); then
        declare -g MIN_PORT=$min_port
        declare -g MAX_PORT=$max_port
    else
        echo "[ERROR] invalid port"
    fi
}

function set_gs_additional_deploy_params() {
    print_menu_header "PARAMETERS" "Enter additional deployment parameters (ENTER to skip):"
    read -p "#? " extra_params
    [[ ! -z $extra_params ]] && declare -g DEPLOY_PARAMS="$extra_params"
}

function set_gs_options_ext() {
    local mode=$1   # interactive | unattended
    if [[ $mode == "interactive" ]]; then
        print_menu_header "GS_OPTIONS_EXT" "Enter additional JVM options (ENTER to skip):"
        read -p "#? " ext_opt
        [[ ! -z $ext_opt ]] && declare -g GS_EXT=$ext_opt
    fi
    if [[ ! -z $GS_EXT ]]; then
        GS_EXT=$(echo "$GS_EXT" | sed "s/\[ZONE\]/$ZONE/g")
        GS_EXT=$(echo "$GS_EXT" | sed "s/\[SERVICE\]/$SERVICE/g")
        GS_EXT=$(echo "$GS_EXT" | sed "s/\[SERVICE_NAME\]/$SERVICE_NAME/g")
    fi
}

function generate_custom_script() {
    if [[ ! -e $GEN_SCRIPT ]]; then
        echo '#!/bin/bash' > $GEN_SCRIPT
        echo -e "\n# $(basename $0) automated script\n" >> $GEN_SCRIPT
    fi
    echo "# service: $(basename ${SERVICE_PATH})" >> $GEN_SCRIPT
    echo -e "$(realpath $0) full -s ${SERVICE_PATH} -j ${JAR} -c ${NUM_OF_CONTAINERS} -m ${JVM_RAM} -i ${NUM_OF_INSTANCES} -p 8113-8311\n" >> $GEN_SCRIPT
    sleep 0.1
    echo "automated service '$SERVICE' complete."
}

function service_presets() {
    local opt=$1
    [[ ! -z $2 ]] && [[ $2 == "--silent" ]] && local silent=true
    if [[ $opt == "init" ]]; then
        $silent || print_menu_header "REVIEW PRESETS" "Presets are available for selected service(s):"
        $silent || echo "[SERVICE NAME: $SERVICE]"
        if [[ ! -e $SERVICE_PATH/$SERVICE_PRESETS ]]; then
            echo "NUM_OF_CONTAINERS=1" > $SERVICE_PATH/$SERVICE_PRESETS
            echo "JVM_RAM=1g" >> $SERVICE_PATH/$SERVICE_PRESETS
            echo "NUM_OF_INSTANCES=1" >> $SERVICE_PATH/$SERVICE_PRESETS
            latest_jar=$(find $SERVICE_PATH -name "*jar*" | sort -rn | head -1)
            echo "JAR=$latest_jar" >> $SERVICE_PATH/$SERVICE_PRESETS
            echo "PORT_RANGE=8113-8311" >> $SERVICE_PATH/$SERVICE_PRESETS
        fi
        $silent || while read line; do echo "   $line" ; done < $SERVICE_PATH/$SERVICE_PRESETS
        $silent || while true; do
            unset answer
            echo ; read -p "Accept and proceed? [Y/n] " answer
            [[ -z $answer ]] && { declare -g USE_SERVICE_PRESETS=true ; break ; }
            case ${answer,,} in
                y*) declare -g USE_SERVICE_PRESETS=true ; break ;;
                n*) declare -g USE_SERVICE_PRESETS=false ; break ;;
                *) echo "invalid input. type 'Y' or 'n' or press ENTER" ;;
            esac
        done
    elif [[ $opt == "update" ]]; then
        [[ ! -z $NUM_OF_CONTAINERS ]] && [[ $NUM_OF_CONTAINERS != "" ]] && \
        sed -i "s/^NUM_OF_CONTAINERS=.*/NUM_OF_CONTAINERS=$NUM_OF_CONTAINERS/" $SERVICE_PATH/$SERVICE_PRESETS        
        [[ ! -z $JVM_RAM ]] && [[ $JVM_RAM != "" ]] && \
        sed -i "s/^JVM_RAM=.*/JVM_RAM=$JVM_RAM/" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $NUM_OF_INSTANCES ]] && [[ $NUM_OF_INSTANCES != "" ]] && \
        sed -i "s/^NUM_OF_INSTANCES=.*/NUM_OF_INSTANCES=$NUM_OF_INSTANCES/" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $JAR ]] && [[ $JAR != "" ]] && \
        sed -i "s|^JAR=.*|JAR=$JAR|" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $PORT_RANGE ]] && [[ $PORT_RANGE != "" ]] && \
        sed -i "s/^PORT_RANGE=.*/PORT_RANGE=$PORT_RANGE/" $SERVICE_PATH/$SERVICE_PRESETS
        [[ ! -z $GS_EXT ]] && [[ $GS_EXT != "" ]] && {
            sed -i '/GS_EXT=/d' $SERVICE_PATH/$SERVICE_PRESETS
            echo "GS_EXT=$GS_EXT" >> $SERVICE_PATH/$SERVICE_PRESETS
        }
        [[ ! -z $DEPLOY_PARAMS ]] && [[ $DEPLOY_PARAMS != "" ]] && {
            sed -i '/DEPLOY_PARAMS=/d' $SERVICE_PATH/$SERVICE_PRESETS
            echo "DEPLOY_PARAMS=$DEPLOY_PARAMS" >> $SERVICE_PATH/$SERVICE_PRESETS
        }
    elif [[ $opt == "set" ]]; then
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "NUM_OF_CONTAINERS=")
        [[ $test != "" ]] && declare -g NUM_OF_CONTAINERS=$(echo "$test" | grep "NUM_OF_CONTAINERS=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "JVM_RAM=")
        [[ $test != "" ]] && declare -g JVM_RAM=$(echo "$test" | grep "JVM_RAM=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "NUM_OF_INSTANCES=")
        [[ $test != "" ]] && declare -g NUM_OF_INSTANCES=$(echo "$test" | grep "NUM_OF_INSTANCES=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "JAR=")
        [[ $test != "" ]] && declare -g JAR=$(echo "$test" | grep "JAR=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "PORT_RANGE=")
        [[ $test != "" ]] && declare -g PORT_RANGE=$(echo "$test" | grep "PORT_RANGE=" | cut -d= -f2-) && set_port_range
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "GS_EXT=")
        [[ $test != "" ]] && declare -g GS_EXT=$(echo "$test" | grep "GS_EXT=" | cut -d= -f2-)
        local test=$(cat $SERVICE_PATH/$SERVICE_PRESETS | grep "DEPLOY_PARAMS=")
        [[ $test != "" ]] && declare -g DEPLOY_PARAMS=$(echo "$test" | grep "DEPLOY_PARAMS=" | cut -d= -f2-)
    fi
}

function undeploy_pu() {
    # try to set JAVA_HOME
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi
    logger $LOG $GS_EXEC service undeploy $SERVICE_NAME
}

function kill_containers() {
    # try to set JAVA_HOME
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi
    logger $LOG $GS_EXEC container kill --zones=$ZONE
}

function create_containers() {
    # abort if no mem info found
    if [[ ${#SPACE_MEM_INFO[@]} == 0 ]]; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') [ERROR] no space hosts memory info found." >> $LOG
        return
    fi
    
    # try to set JAVA_HOME
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi

    local count=0
    declare -A runtime_mem_info
    
    # create a duplicate runtime array from SPACE_MEM_INFO
    for k in "${!SPACE_MEM_INFO[@]}"; do runtime_mem_info["$k"]="${SPACE_MEM_INFO[$k]}" ; done

    while [[ $count -lt $NUM_OF_CONTAINERS ]]; do
        if [[ $count -ge $NUM_OF_SPACES ]] && [[ $(expr $count % $NUM_OF_SPACES) -eq 0 ]]; then
            # reset runtime array back when count is reached
            for k in "${!SPACE_MEM_INFO[@]}"; do runtime_mem_info["$k"]="${SPACE_MEM_INFO[$k]}" ; done
        fi
        local optimal_host=$(get_max_free_mem_host runtime_mem_info)
        logger $LOG $GS_EXEC container create --count=1 --memory=$JVM_RAM --zone=$ZONE $optimal_host
        unset runtime_mem_info["$optimal_host"]       # removing last used host from the list
        ((count++))
    done    
}

function deploy_pu() {
    # try to set JAVA_HOME
    if [[ -n JAVA_HOME ]] && [[ $(rpm -qa | grep java | head -1) != "" ]]; then
        export JAVA_HOME="$(which java | sed 's;bin/java;;g')"
    fi

    [[ ! -z $DEPLOY_PARAMS ]] && \
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] adding additional deploy parameters: $DEPLOY_PARAMS" >> $LOG
    if [[ ! -z $GS_EXT ]]; then
        export GS_OPTIONS_EXT="$GS_EXT"
        echo "$(date '+%Y-%m-%d %H:%M:%S') [EXEC] export GS_OPTIONS_EXT=$GS_EXT" >> $LOG
    fi
    
    logger $LOG $GS_EXEC service deploy $SERVICE_NAME \
    --instances=$NUM_OF_INSTANCES --zones=$ZONE $DEPLOY_PARAMS \
    -p minPort=$MIN_PORT -p maxPort=$MAX_PORT -p consul.host=localhost $JAR
}


#
# # # MAIN # # #
#

VERBOSE=false
BASH_REQUIRED=4.4
GS_ROOT=/dbagiga
export GS_HOME="$GS_ROOT/gigaspaces-smart-ods"
GS_LOG_ROOT=/dbagigalogs
GS_EXEC=$GS_HOME/bin/gs.sh
LOG=${GS_LOG_ROOT}/$(basename $0).log
BASE_DIR=$(dirname $(realpath $0))
SERVICES_DIR=${BASE_DIR}/services
SERVICE_PRESETS="service.presets"
declare -A SPACE_MEM_INFO
declare -a SERVICES_PATHS
GEN_SCRIPT="/tmp/$(basename $0)_autogen_$(date '+%Y%m%d')-$RANDOM.sh"

# text styles
_b=$(tput bold)     # bold text
_nb=$(tput sgr0)    # not bold text
_r='\033[0;31m'     # red text
_lr='\033[1;31m'    # light red text
_g='\033[0;32m'     # green text
_lg='\033[1;32m'    # light green text
_o='\033[0;33m'     # orange text
_y='\033[1;33m'     # yellow text
_b='\033[0;34m'     # blue text
_lb='\033[1;34m'    # light blue text
_p='\033[0;35m'     # purple text
_lp='\033[1;35m'    # light purple text
_c='\033[0;36m'     # cyan text
_lc='\033[1;36m'    # light cyan text
_w='\033[0;37m'     # white text
_res='\033[0m'      # no colour

# verify bash version compatibility
if ! bash_version_ok; then
    echo "[ERROR] incompatible BASH version. must be ${BASH_REQUIRED} or newer."
    exit 1
fi

# check host.yaml exists
if [[ ! -e ${ENV_CONFIG}/host.yaml ]]; then
    logger $LOG echo "[ERROR] host.yaml not found. aborting!"
    exit
fi

# check folder structure
if [[ ! -d $SERVICES_DIR ]]; then
    mkdir $SERVICES_DIR
    echo
    logger $LOG echo "[INFO] 'services' folder not found. created it."
    logger $LOG echo "[INFO] put all service folders in it."
    echo
    exit
fi
if [[ $(find $SERVICES_DIR -mindepth 1 -maxdepth 1 -type d | wc -l) == 0 ]]; then
    echo
    logger $LOG echo "[WARNING] no data found in 'services' folder. nothing to deploy"
    exit
fi

# parse verbosity for interactive exec
if [[ $1 == '-v' ]]; then
    VERBOSE=true
    shift
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] verbose mode: ON" >> $LOG
fi

# show usage without initializing
[[ $1 == '-h' ]] && usage && exit

# get credentials if env is secured
get_auth

# get manager host
for m in $(get_cluster_hosts "manager"); do
    if is_manager_rest_ok $m ; then
        MANAGER=$m
        break
    fi
done
if [[ -z $MANAGER ]]; then
    echo
    logger $LOG echo "[ERROR] no avaialable managers found!"
    exit
fi

# initialize creation of SPACE_MEM_INFO
clear ; echo "Starting $(basename $0) ..."
mem_used_per_space_host
echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] space info acquired" >> $LOG

# get number of space servers
NUM_OF_SPACES=$(get_cluster_hosts space | wc -w)

# parse arguments
if [[ $# -ne 0 ]]; then     # if unattended execution
    while [[ $# -gt 0 ]]; do
        case $1 in
            full|create|deploy|kill|undeploy|list|fd-gen|version) cmd=$1 ; shift ;;
            -s) shift ; SERVICES_PATHS+=("$(realpath $(echo $1 | sed 's|/$||'))") ; shift ;;
            -c) shift ; NUM_OF_CONTAINERS=$1 ; shift ;;
            -m) shift ; JVM_RAM=$1 ; shift ;;
            -i) shift ; NUM_OF_INSTANCES=$1 ; shift ;;
            -j) shift ; JAR="$1" ; shift ;;
            -p) shift ; PORT_RANGE="$1" ; shift ;;
            -x) shift ; DEPLOY_PARAMS="$1" ; shift ;;
            -o) shift ; GS_EXT="$1"; shift ;;
            -v) VERBOSE=true ; shift ;;
            -h*) usage ; exit ;;
            *) usage ; exit ;;
        esac
    done
    if $VERBOSE ; then
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] verbose mode: ON" >> $LOG
    else
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] verbose mode: OFF" >> $LOG
    fi
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] mode: unattended" >> $LOG
    if [[ -z $cmd ]]; then
        logger $LOG echo "[ERROR] missing command. use -h for help."
        exit
    fi
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] command: '$cmd'" >> $LOG
    while [[ ${#SPACE_MEM_INFO[@]} -ne $NUM_OF_SPACES ]]; do
        echo "waiting for space info..."
        sleep 0.5
    done
    if [[ $cmd == "list" ]]; then
        list_resources
        exit
    elif [[ $cmd == "version" ]]; then
        echo "$VERSION"
        exit
    fi
    for ((i=0; i<${#SERVICES_PATHS[@]}; i++)); do
        SERVICE_PATH="${SERVICES_PATHS[$i]}"
        case $cmd in
            "full")
                get_services unattended
                get_num_of_containers unattended
                get_memory_allocation unattended
                get_num_of_instances unattended
                get_jar_file unattended
                set_port_range
                set_gs_options_ext
                $VERBOSE && print_vars
                echo -e "\n>> Deploying service '${SERVICE}'"
                undeploy_pu
                kill_containers
                create_containers
                deploy_pu
                ;;
            "create")
                get_services unattended
                get_num_of_containers unattended
                get_memory_allocation unattended
                $VERBOSE && print_vars
                create_containers
                ;;
            "deploy")
                get_services unattended
                get_num_of_instances unattended
                get_jar_file unattended
                set_port_range
                set_gs_options_ext
                $VERBOSE && print_vars
                deploy_pu
                ;;
            "kill")
                get_services unattended
                $VERBOSE && print_vars
                kill_containers
                ;;
            "undeploy")
                get_services unattended
                $VERBOSE && print_vars
                undeploy_pu
                ;;
        esac
    done
else    # if interactive execution
    $VERBOSE || echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] verbose mode: OFF" >> $LOG
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] mode: interactive" >> $LOG
    
    # get operation
    OPERATIONS=(
        "Full Deployment"
        "Create Containers"
        "Deploy PU"
        "Kill Containers"
        "Undeploy PU"
        "List Resources"
        "Script Generator"
        )
    print_gs_logo
    print_menu_header "OPERATIONS" "What do you wish to do?"
    print_menu_items single OPERATIONS[@]
    op_choice=${OPERATIONS[${menu_choices[0]}]}
    echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] command: '$op_choice'" >> $LOG
    
    if [[ $op_choice == "Script Generator" ]]; then
        print_gs_logo
        print_menu_header "SCRIPT GENERATOR" "Generate unattended execution script"
        echo -e "[NOTE]\n"
        echo "A single script will be generated for selected service(s)."
        echo "Only default parameters will be used for services."
        while true; do
            unset answer
            echo ; read -p "Proceed? [Y/n] " answer
            [[ -z $answer ]] && answer=y
            case ${answer,,} in
                y*) break ;;
                n*) exit ;;
                *) echo "invalid input. type 'Y' or 'n' or press ENTER" ;;
            esac
        done
    elif [[ $op_choice == "List Resources" ]]; then
        print_gs_logo
        $VERBOSE && print_vars
        list_resources
        exit
    fi

    # get services
    AVAILABLE_SERVICES=($(find $SERVICES_DIR -mindepth 1 -maxdepth 1 -type d | sed "s|${SERVICES_DIR}/||"))
    print_gs_logo ; get_services interactive
    
    # excute operations for each service
    for index in ${menu_choices[@]}; do
        SERVICE_PATH="$SERVICES_DIR/${AVAILABLE_SERVICES[$index]}"
        SERVICE=$(echo $(basename "$SERVICE_PATH") | tr '[:upper:]' '[:lower:]')
        ZONE=$SERVICE
        SERVICE_NAME="${SERVICE}_service"
        echo "$(date '+%Y-%m-%d %H:%M:%S') [INFO] selected service: '$SERVICE'" >> $LOG
        AVAILABLE_JARS=($(find $SERVICE_PATH -mindepth 1 -maxdepth 1 -type f -name "*.jar" -exec basename {} \;))
        case $op_choice in
            "Full Deployment")
                service_presets init
                if $USE_SERVICE_PRESETS; then
                    service_presets set
                else
                    get_num_of_containers interactive
                    get_memory_allocation interactive
                    get_num_of_instances interactive
                    get_jar_file interactive
                    JAR="${SERVICE_PATH}/${AVAILABLE_JARS[${menu_choices[0]}]}"
                    set_port_range interactive
                    set_gs_additional_deploy_params
                    set_gs_options_ext interactive
                    service_presets update
                fi
                print_gs_logo
                $VERBOSE && print_vars
                echo -e "\nInitializing $op_choice for service: '$SERVICE' ..."
                undeploy_pu
                kill_containers
                create_containers
                deploy_pu
                ;;
            "Create Containers")
                service_presets init
                if $USE_SERVICE_PRESETS; then
                    service_presets set
                else
                    get_num_of_containers interactive
                    get_memory_allocation interactive
                    service_presets update
                fi
                print_gs_logo
                $VERBOSE && print_vars
                echo -e "\nInitializing $op_choice for service: '$SERVICE' ..."
                create_containers
                ;;
            "Deploy PU")
                service_presets init
                if $USE_SERVICE_PRESETS; then
                    service_presets set            
                else
                    get_num_of_instances interactive
                    get_jar_file interactive
                    JAR="${SERVICE_PATH}/${AVAILABLE_JARS[${menu_choices[0]}]}"
                    set_port_range interactive
                    set_gs_additional_deploy_params
                    set_gs_options_ext interactive
                    service_presets update
                fi
                print_gs_logo
                $VERBOSE && print_vars
                echo -e "\nInitializing $op_choice for service: '$SERVICE' ..."
                deploy_pu
                ;;
            "Kill Containers")
                print_gs_logo
                $VERBOSE && print_vars
                echo -e "\nInitializing $op_choice for service: '$SERVICE' ..."
                kill_containers
                ;;
            "Undeploy PU")
                print_gs_logo
                $VERBOSE && print_vars
                echo -e "\nInitializing $op_choice for service: '$SERVICE' ..."
                undeploy_pu
                ;;
            "Script Generator")
                service_presets init --silent
                service_presets set
                echo ; generate_custom_script
                ;;
            "Quit")
                exit 0
                ;;
        esac
    done
    # post execution
    if [[ $op_choice == "Script Generator" ]]; then
        echo -e "\n\n* Automated script generated as '$GEN_SCRIPT'\n"
    fi
fi

exit


### TO BE DONE ###
# - calculate and warn against exceeding available memory
# - menu navigation enhancements (ESC / Go back)
